<?php if ( ! defined( 'DEVIL_SYS_CORE_PATH' ) ) exit( 'No direct script access allowed' );
/**
  @brief        ★★★★★ 核心 BootStart ( 入口類 )
  @version      1.1.1
  @date         2015-04-01 by Vam
  @since        1.1.1 -> 增加 CLI 指令模式。
  @since        1.1.0 -> 增加 Loader讀取器來掛載library、help、model。
  @since        1.0.0 -> 新增此新類別。
  @pre          核心流程
**/

class Bootstart
{
    /**
    @brief      核心類的類別前贅詞
    **/
    public static $_CoreNameSpaces = 'Core_';

    /**
    @brief      存放自動載入 核心類
    **/
    public static $_lib = array();

    /**
    @brief      存放自動載入 核心類(名稱)
    **/
    public static $_libAuto = array();

    /**
    @brief      存放手動載入 核心類(名稱)
    **/
    public static $_libManually = array();

    /**
    @brief      存放手動載入 模組(名稱)
    **/
    public static $_modManually = array();

    /**
    @brief      存放手動載入 輔助函式(名稱)
    **/
    public static $_helpManually = array();

    /**
    @brief      存放自動載入 模組類
    **/
    public static $_mod = array();

    /**
    @brief      存放自動載入核心、專案內的輔助函式
    **/
    public static $_help = array();

    /**
    @brief      存放專案的設定檔、資料庫帳密等等
    **/
    public static $_config = array();

    /**
    @brief      存放專案的 bettype、 subid 等設定檔
    **/
    public static $_hip = array();

    /**
    @brief      除錯用
    **/
    public static $_debug = array();

    /**
    @brief      存放當前的控制器
    **/
    public static $_Controller;

    /**
    @brief      存放當前的控制器的實體
    **/
    public static $_Controller_Object;

    /**
    @brief      存放當前的控制器中的方法
    **/
    public static $_Method;

    /**
    @brief      存放當前的控制器中方法需要的參數資料
    **/
    public static $_Uri = array();

    /**
    @brief      取得 MVC Version 的版本號
    @return     String  核心版本號
    @remarks    此範例結果：1.0.0。
    @code{.unparsed}
    BootStrap::Framework_v();
    @endcode
    **/
    public static function Framework_v()
    {
        return '1.1.1';
    }

    /**
    @brief      初始化
    **/
    private static function init()
    {
        # ----------------------------------------------------------------------
        # 引入除錯控制器,如果.php檔案不存在，就顯示錯誤
        # ----------------------------------------------------------------------
        if ( ! file_exists( DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'Debug.php' ) )
        {
            exit( 'Debug class is not exists.' );
        }
        else
        {
            require DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'Debug.php';
        }
        # ----------------------------------------------------------------------
        # 實體化除錯模式
        # ----------------------------------------------------------------------
        self::$_debug = new Debug();
        # ----------------------------------------------------------------------
        # 建立一個核心的啟動訊息
        # ----------------------------------------------------------------------
        self::$_debug->addMessage( 'log' , 'Bootstart-Core-Init-Strat' , array() );
        # ----------------------------------------------------------------------
        # 引入核心控制項,如果.php檔案不存在，就顯示錯誤
        # ----------------------------------------------------------------------
        if ( ! file_exists( DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'Controller.php' ) )
        {
            exit( 'Controller class is not exists.' );
        }
        else
        {
            require DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'Controller.php';
        }
        # ----------------------------------------------------------------------
        # 引入核心模組,如果.php檔案不存在，就顯示錯誤
        # ----------------------------------------------------------------------
        if ( ! file_exists( DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'Model.php' ) )
        {
            exit( 'Model class is not exists.' );
        }
        else
        {
            require DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'Model.php';
        }
        # ----------------------------------------------------------------------
        # 引入視圖,如果.php檔案不存在，就顯示錯誤
        # ----------------------------------------------------------------------
        if ( ! file_exists( DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'View.php' ) )
        {
            exit( 'View class is not exists.' );
        }
        else
        {
            require DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'View.php';
        }
        # ----------------------------------------------------------------------
        # 自動加載系統類別庫
        # ----------------------------------------------------------------------
        self::setAutoLibs();
        # ----------------------------------------------------------------------
        # 自動加載系統輔助函式
        # ----------------------------------------------------------------------
        self::setAutohelper();
    }

    /**
    @brief      引入要自動加載的系統類 ( 核心的 )
    **/
    private static function setAutoLibs()
    {
        self::$_libAuto = array
        (
            # ------------------------------------------------------------------
            # 錯誤提示類
            # ------------------------------------------------------------------
            'Error' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'Error' ,
            # ------------------------------------------------------------------
            # 錯誤提示類
            # ------------------------------------------------------------------
            'PHPLog' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'PHPLog' ,
            # ------------------------------------------------------------------
            # 工具類
            # ------------------------------------------------------------------
            'Widget' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'Widget' ,
            # ------------------------------------------------------------------
            # 加密類
            # ------------------------------------------------------------------
            'EncryptDecryt' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'EncryptDecryt' ,
            # ------------------------------------------------------------------
            # 讀取器類
            # ------------------------------------------------------------------
            'Loader' => DEVIL_SYS_CORE_PATH . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'Loader' ,
            # ------------------------------------------------------------------
            # Cookie 操作類
            # ------------------------------------------------------------------
            'Cookie' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'Cookie' ,
            # ------------------------------------------------------------------
            # 快取類
            # ------------------------------------------------------------------
            'Cache' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'Cache' ,
            # ------------------------------------------------------------------
            # UserAgent 工具
            # ------------------------------------------------------------------
            'UserAgent' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'UserAgent' ,
            # ------------------------------------------------------------------
            # Input 過濾類
            # ------------------------------------------------------------------
            'Input' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'Input' ,
            # ------------------------------------------------------------------
            # Date 日期操作類
            # ------------------------------------------------------------------
            'Date' => DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . 'Date' ,
        );
    }

    /**
    @brief      引入要自動加載核心內的輔助函式 ( 核心的 )
    **/
    private static function setAutohelper()
    {
        self::$_help = array
        (
            # ------------------------------------------------------------------
            # 陣列 輔助函式
            # ------------------------------------------------------------------
            #'array' => DEVIL_SYS_HELPER_PATH . DIRECTORY_SEPARATOR . 'array_helper'
        );
    }

    /**
    @brief      建立所有應用
    @param      Array       $config 專案內的資料庫、前贅詞設定、Cache設定
    @param      Array       $autoload 專案內自動加載的類、模組、輔助函式設定
    @param      Array       $_hipArr 所有專案共用的設定
    **/
    public static function run( $config = array() , $autoload = array() , $_hipArr = array() )
    {
        # ----------------------------------------------------------------------
        # 初始化變數
        # ----------------------------------------------------------------------
        $url_array = array();
        # ----------------------------------------------------------------------
        # 存放資料庫連線設定值
        # ----------------------------------------------------------------------
        self::$_config = $config['system'];
        # ----------------------------------------------------------------------
        # 這邊只會整理有開放的全域陣列
        # ----------------------------------------------------------------------
        self::$_hip = $_hipArr;
        # ----------------------------------------------------------------------
        # 初始化
        # ----------------------------------------------------------------------
        self::init();
        # ----------------------------------------------------------------------
        # 建立一個 "全域陣列" 的啟動訊息
        # ----------------------------------------------------------------------
        self::$_debug->addMessage( 'log' , 'Bootstart-Core-hipArr' , array() );
        # ----------------------------------------------------------------------
        # 呼叫 "自動載入類別" 的功能
        # ----------------------------------------------------------------------
        self::autoload( $autoload );
        # ----------------------------------------------------------------------
        # 如果是 Command Line Interface ( CLI )
        # ----------------------------------------------------------------------
        if ( php_sapi_name() == 'cli' )
        {
            if ( isset( $_SERVER['argv'] ) )
            {
                # --------------------------------------------------------------
                # 刪除第一個參數值
                # --------------------------------------------------------------
                unset( $_SERVER['argv'][0] );
                # --------------------------------------------------------------
                # 迴圈整理傳入的參數
                # --------------------------------------------------------------
                foreach( $_SERVER['argv'] as $ArgvValue )
                {
                    $url_array[] = $ArgvValue;
                }
            }
            else
            {
                exit( 'Error argv.' );
            }
        }
        else
        {
            # ----------------------------------------------------------------------
            # 先過濾取得 路由 參數
            # ----------------------------------------------------------------------
            $uri = self::$_lib[self::$_CoreNameSpaces . 'Input']->get( 'url' , 'string' );
            # ----------------------------------------------------------------------
            # 如果取不到，就導向至預設的 Controller 避免發生 Notice
            # ----------------------------------------------------------------------
            if ( ! $uri )
            {
                Core_Redirect( DEVIL_APP_DEFAULT_CONTROLLER );
            }
            # ----------------------------------------------------------------------
            # 移除最後一個分隔符號
            # ----------------------------------------------------------------------
            $url_array = explode( '/' , rtrim( $uri , '/' ) );
        }

        # ----------------------------------------------------------------------
        # 交給路由處理
        # ----------------------------------------------------------------------
        self::router( $url_array );
    }

    /**
    @brief 引入要自動加載的核心類，並實體化到 $_lib 存放被用呼叫
    **/
    private static function autoload( $autoload )
    {
        # ----------------------------------------------------------------------
        # 核心內預設一定要自動加載的，會在此處執行處理
        # ----------------------------------------------------------------------
        foreach ( self::$_libAuto as $key => $value )
        {
            # ------------------------------------------------------------------
            # 引入類別檔案,如果.php檔案不存在，就顯示錯誤
            # ------------------------------------------------------------------
            if ( ! file_exists( $value . '.php' ) )
            {
                exit( self::$_libAuto[$key] . ' class is not exists.' );
            }
            else
            {
                require ( $value . '.php' );
            }
            # ------------------------------------------------------------------
            # 把字首轉大寫
            # ------------------------------------------------------------------
            $lib = ucfirst( $key );
            # ------------------------------------------------------------------
            # 重新產生一次核心類別的類名稱
            # ------------------------------------------------------------------
            $key = self::$_CoreNameSpaces . $key;
            # ------------------------------------------------------------------
            # 把轉換後的類別名稱實體化
            # ------------------------------------------------------------------
            self::$_lib[$key] = new $lib;
        }
        # ----------------------------------------------------------------------
        # 建立一個 "核心自動載入類別" 的完成訊息
        # ----------------------------------------------------------------------
        self::$_debug->addMessage( 'log' , 'Bootstart-Core-AutoLibs' , self::$_lib );
        # ----------------------------------------------------------------------
        # 引入輔助函式
        # ----------------------------------------------------------------------
        foreach ( self::$_help as $keys => $values )
        {
            # ------------------------------------------------------------------
            # 引入 "核心" 的每個輔助函式檔案,如果.php檔案不存在，就使用提示錯誤
            # ------------------------------------------------------------------
            if ( ! file_exists( $values . '.php' ) )
            {
                exit( self::$_help[$keys] . ' class is not exists.' );
            }
            else
            {
                require ( $values . '.php' );
            }
        }
        # ----------------------------------------------------------------------
        # 建立一個 "核心自動載入輔助函式" 的完成訊息
        # ----------------------------------------------------------------------
        self::$_debug->addMessage( 'log' , 'Bootstart-Core-AutoHelper' , self::$_help );
        # ----------------------------------------------------------------------
        # 如果各自 "專案" 內有需設定需要自動加載的，會在此處理各項加載動作
        # ----------------------------------------------------------------------
        # 引入且實體化類別
        # ----------------------------------------------------------------------
        foreach ( $autoload['libraries'] as $libkey => $libclass )
        {
            # ------------------------------------------------------------------
            # 如果指定的 "類別" 名稱不為空 就開始 引入類別
            # ------------------------------------------------------------------
            if ( $libclass != '' )
            {
                self::newLib( $libclass );
            }
        }
        # ----------------------------------------------------------------------
        # 建立一個 "專案自動載入類別" 的完成訊息
        # ----------------------------------------------------------------------
        self::$_debug->addMessage( 'log' , 'Bootstart-Apps-AutoLibs' , $autoload['libraries'] );
        # ----------------------------------------------------------------------
        # 如果各自 "專案" 內有需設定需要自動加載的，會在此處理各項加載動作
        # ----------------------------------------------------------------------
        # 引入且實體化類別
        # ----------------------------------------------------------------------
        foreach ( $autoload['models'] as $modelkey => $modelclass )
        {
            # ------------------------------------------------------------------
            # 如果指定的 "資料模組" 名稱不為空 就開始 引入資料模組
            # ------------------------------------------------------------------
            if ( $modelclass != '' )
            {
                self::newModel( $modelclass );
            }
        }

        # ----------------------------------------------------------------------
        # 建立一個 "專案自動載入資料模組" 的完成訊息
        # ----------------------------------------------------------------------
        self::$_debug->addMessage( 'log' , 'Bootstart-Apps-AutoModels' , $autoload['models'] );
        # ----------------------------------------------------------------------
        # 如果各自 "專案" 內有需設定需要自動加載的輔助函式，會在此處理各項加載動作
        # ----------------------------------------------------------------------
        foreach ( $autoload['helpers'] as $helpkey => $helpname  )
        {
            # ------------------------------------------------------------------
            # 如果指定的 "輔助函式" 名稱不為空 就開始 引入輔助函式
            # ------------------------------------------------------------------
            if ( $helpname != '' )
            {
                self::newHelper( $helpname );
            }
        }
        # ----------------------------------------------------------------------
        # 建立一個 "專案自動載入輔助函式" 的完成訊息
        # ----------------------------------------------------------------------
        self::$_debug->addMessage( 'log' , 'Bootstart-Apps-AutoHelpers' , $autoload['helpers'] );
        # ----------------------------------------------------------------------
        # 初始化 專案的 Cache 設定
        # ----------------------------------------------------------------------
        if ( is_object( self::$_lib[self::$_CoreNameSpaces . 'Cache'] ) )
        {
            self::$_lib[self::$_CoreNameSpaces . 'Cache']->init
            (
                self::$_config['cache']['cache_dir'] ,
                self::$_config['cache']['cache_prefix'] ,
                self::$_config['cache']['cache_time'] ,
                self::$_config['cache']['cache_mode']
            );
        }
    }

    /**
    @brief      手動加載需要的輔助函式
    @param      String      $helper_name 輔助函式檔案名稱
    @return     Object
    @remarks    通常核心中的輔助函式會於 "核心啟動時" 自動加載，但也有可能有部分輔助函式需要手動加載
    @code{.unparsed}
    Bootstart::newHelper( 'array' );
    @endcode
    @remarks    當然也可以一次加載多個
    @code{.unparsed}
    Bootstart::newHelper( array( 'array' , 'download' ) );
    @endcode
    @attention  請註意，若核心、專案有相同的輔助函式存在時，優先掛載專案內的。
    **/
    public static function newHelper( $helper_name )
    {
        # ----------------------------------------------------------------------
        # 初始化變數
        # ----------------------------------------------------------------------
        $app_help = $sys_help = '';
        # ----------------------------------------------------------------------
        # 設定要 "專案內" 要載入的輔助函式 路徑
        # 專案內的輔助函式 名稱前贅 是在專案的 Config 中設定的，目前是 My
        # ----------------------------------------------------------------------
        $app_help = DEVIL_APP_HELPER_PATH . self::$_config['helper']['prefix'] . '_' . $helper_name . '_helper.php';
        # ----------------------------------------------------------------------
        # 設定要 "核心內" 要載入的輔助函式 路徑
        # ----------------------------------------------------------------------
        $sys_help = DEVIL_SYS_HELPER_PATH . DIRECTORY_SEPARATOR . $helper_name . '_helper.php';
        # ----------------------------------------------------------------------
        # 若判斷指定 "專案內" 的自訂擴充輔助函式檔案有存在時
        # ----------------------------------------------------------------------
        if ( file_exists( $app_help ) )
        {
            # ------------------------------------------------------------------
            # 引入指定於 "專案內的 輔助函式" 名稱檔案
            # ------------------------------------------------------------------
            require ( $app_help );
            # ------------------------------------------------------------------
            # 加載成功後，會於 " Bootstart的 $_help " 指定的輔助函式，設定為 TRUE 方便 Controller 判斷有沒設定成功
            # ------------------------------------------------------------------
            self::$_help[self::$_config['helper']['prefix'] . '_' . $helper_name] = 'TRUE';
            # ------------------------------------------------------------------
            # 將輔助函式名稱存放至手動加載輔助函式陣列中
            # ------------------------------------------------------------------
            self::$_helpManually[self::$_config['helper']['prefix'] . '_' . $helper_name] = " =&gt; Is Operational";
        }
        # ----------------------------------------------------------------------
        # 核心內的輔助函式
        # ----------------------------------------------------------------------
        if ( file_exists( $sys_help ) )
        {
            # ------------------------------------------------------------------
            # 引入指定於 "核心內的 輔助函式" 名稱檔案
            # ------------------------------------------------------------------
            require ( $sys_help );
            # ------------------------------------------------------------------
            # 加載成功後，會於 " Bootstart的 $_help " 指定的輔助函式，設定為 TRUE 方便 Controller 判斷有沒設定成功
            # ------------------------------------------------------------------
            self::$_help[$helper_name] = 'TRUE';
            # ------------------------------------------------------------------
            # 將輔助函式名稱存放至手動加載輔助函式陣列中
            # ------------------------------------------------------------------
            self::$_helpManually[$helper_name] = " =&gt; Is Operational";
        }
        # ----------------------------------------------------------------------
        # 如果核心、專案內都沒有此檔案存在，則錯誤
        # ----------------------------------------------------------------------
        if ( ! file_exists( $app_help ) && ! file_exists( $sys_help ) )
        {
            show_error
            (
                '您所加載的輔助函式【' . $helper_name . '】檔案不存在，請檢查輔助函式檔案路徑是否正確。' .
                '<br />專案下: ' . str_replace( "\\", "/", $app_help ) .
                '<br />核心下: ' . str_replace( "\\", "/", $sys_help )
            );
        }
        # ----------------------------------------------------------------------
        # 建立一個 "手動載入類別" 的完成訊息
        # ----------------------------------------------------------------------
        Bootstart::$_debug->addMessage( 'log' , 'Bootstart-ManualMount-Helper' , self::$_helpManually );
    }

    /**
    @brief      手動加載需要的類別
    @param      String      $class_name 類庫名稱
    @param      String      $_path        類路徑
    @retval     Object
    @remarks    自動尋找核心、專案中的類別並掛載。
    @code{.unparsed}
    Bootstart::newLib( 'Users' );
    @endcode
    @remarks    當然也可以一次加載多個
    @code{.unparsed}
    Bootstart::newLib( array( 'Users' , 'Html' ) );
    @endcode
    @attention  請註意，若核心、專案有相同的類別存在時，優先掛載專案內的。
    **/
    public static function newLib( $class_name , $_path = '' )
    {
        # ----------------------------------------------------------------------
        # 初始化變數
        # ----------------------------------------------------------------------
        $app_lib = $sys_lib = '';
        # ----------------------------------------------------------------------
        # 設置 "專案內" 的類別路徑
        # ----------------------------------------------------------------------
        $app_lib = DEVIL_APP_LIB_PATH . $_path . self::$_config['lib']['prefix'] . '_' . $class_name . '.php';
        # ----------------------------------------------------------------------
        # 設置 "核心內" 的類別路徑
        # ----------------------------------------------------------------------
        $sys_lib = DEVIL_SYS_LIB_PATH . DIRECTORY_SEPARATOR . $_path . $class_name . '.php';
        # ----------------------------------------------------------------------
        # 判斷若 "核心" 內的檔案有存在就處理
        # ----------------------------------------------------------------------
        if ( file_exists( $sys_lib ) )
        {
            # ------------------------------------------------------------------
            # 統一字首轉大寫
            # ------------------------------------------------------------------
            $realclass_name = ucfirst( $class_name );
            # ------------------------------------------------------------------
            # 引入核心 "類別" 檔案
            # ------------------------------------------------------------------
            require ( $sys_lib );
            # ------------------------------------------------------------------
            # 實體化指定的類別檔案
            # ------------------------------------------------------------------
            self::$_lib[self::$_CoreNameSpaces . $realclass_name] = new $realclass_name;
            # ------------------------------------------------------------------
            # 重新產生一次核心類別的類名稱
            # ------------------------------------------------------------------
            $realclass_name = self::$_CoreNameSpaces . $realclass_name;
            # ------------------------------------------------------------------
            # 將類別名稱存放至手動加載類別陣列中
            # ------------------------------------------------------------------
            self::$_libManually[$realclass_name] = " =&gt; Is Operational.";
        }
        # ----------------------------------------------------------------------
        # 判斷若 "專案" 內的檔案有存在就處理
        # ----------------------------------------------------------------------
        if ( file_exists( $app_lib ) )
        {
            # ------------------------------------------------------------------
            # 將類別字首轉大寫
            # ------------------------------------------------------------------
            $realclass_name = ucfirst( self::$_config['lib']['prefix'] ) . '_' . ucfirst( $class_name );
            # ------------------------------------------------------------------
            # 若此類別已定義，則直接回傳類別
            # ------------------------------------------------------------------
            if ( class_exists( $realclass_name ) )
            {
                return self::$_lib[$realclass_name];
            }
            # ------------------------------------------------------------------
            # 引入專案 "類別" 檔案
            # ------------------------------------------------------------------
            require ( $app_lib );
            # ------------------------------------------------------------------
            # 實體化指定的類別檔案
            # ------------------------------------------------------------------
            self::$_lib[$realclass_name] = new $realclass_name;
            # ------------------------------------------------------------------
            # 將類別名稱存放至手動加載類別陣列中
            # ------------------------------------------------------------------
            self::$_libManually[$realclass_name] = " =&gt; Is Operational";
        }
        # ----------------------------------------------------------------------
        # 如果核心、專案中都沒有指定的類別項目，就提示錯誤
        # ----------------------------------------------------------------------
        if ( ! file_exists( $sys_lib ) && ! file_exists( $app_lib ) )
        {
            # ------------------------------------------------------------------
            # 如果是 "非正式" 上線模式，就不顯示類別不存在的提示
            # ------------------------------------------------------------------
            if ( DEVIL_APP_ENVIRONMENT !== 'production' )
            {
                show_error
                (
                    '您所加載的類別【' . $class_name . '】檔案不存在，請檢查類別檔案路徑是否正確。' .
                    '<br />專案下: ' . str_replace( "\\", "/", $app_lib ) .
                    '<br />核心下: ' . str_replace( "\\", "/", $sys_lib )
                );
            }
            # ------------------------------------------------------------------
            # 如果是 "正式" 上線模式，就導向至預設的 "控制器 Controller"
            # ------------------------------------------------------------------
            else
            {
                Core_Redirect( DEVIL_APP_DEFAULT_CONTROLLER );
            }
        }
        # ----------------------------------------------------------------------
        # 建立一個 "手動載入類別" 的完成訊息
        # ----------------------------------------------------------------------
        Bootstart::$_debug->addMessage( 'log' , 'Bootstart-ManualMount-Library' , self::$_libManually );
        # ----------------------------------------------------------------------
        # 回傳已經加載的 "類別 物件"
        # ----------------------------------------------------------------------
        return self::$_lib[$realclass_name];
    }

    /**
    @brief      手動加載需要的 MODEL
    @param      String $model_name 模組名稱
    @param      String $_path 路徑
    @return     Object
    @remarks    掛載專案中的指定模組。
    @code{.unparsed}
    Bootstart::newModel( 'Users' );
    @endcode
    @remarks    當然也可以一次加載多個
    @code{.unparsed}
    Bootstart::newModel( array( 'Users' , 'Amount' ) );
    @endcode
    **/
    public static function newModel( $model_name , $_path = DEVIL_APP_MODEL_PATH )
    {
        # ----------------------------------------------------------------------
        # 初始化變數
        # ----------------------------------------------------------------------
        $app_model = '';
        # ----------------------------------------------------------------------
        # 設置 "資料模組" 的路徑
        # ----------------------------------------------------------------------
        $app_model = $_path . $model_name . '_model.php';
        # ----------------------------------------------------------------------
        # 若 指定的 "資料模組" 檔案有存在則...
        # ----------------------------------------------------------------------
        if ( file_exists( $app_model ) )
        {
            # ------------------------------------------------------------------
            # 引入核心 "資料模組" 檔案
            # ------------------------------------------------------------------
            require ( $app_model );
            # ------------------------------------------------------------------
            # 將 "資料模組" 的字首 轉大寫，並加上 _Model 區分
            # ------------------------------------------------------------------
            $model_name = ucfirst( $model_name ) . '_Model';
            # ------------------------------------------------------------------
            # 將資料模組名稱存放至手動加載資料模組陣列中
            # ------------------------------------------------------------------
            self::$_modManually[$model_name] = " =&gt; Is Operational.";
            # ------------------------------------------------------------------
            # 實體化指定的 "資料模組"
            # ------------------------------------------------------------------
            self::$_mod[$model_name] = new $model_name;
        }
        else
        {
            show_error
            (
                '您所加載的模組【' . $model_name . '】檔案不存在，請檢查模組檔案路徑是否正確。' .
                '<br />專案下: ' . str_replace( "\\", "/", $app_model )
            );
        }
        # ----------------------------------------------------------------------
        # 建立一個 "手動載入類別" 的完成訊息
        # ----------------------------------------------------------------------
        Bootstart::$_debug->addMessage( 'log' , 'Bootstart-ManualMount-Model' , self::$_modManually );
        # ----------------------------------------------------------------------
        # 回傳已經加載的 "資料模組 物件"
        # ----------------------------------------------------------------------
        return self::$_mod[$model_name];
    }

    /**
    @brief      路由處理
    @param      Array       $url 路由參數資料
    **/
    public static function router( $url )
    {
        # ----------------------------------------------------------------------
        # 運用空陣列是 FALSE的特性
        # ----------------------------------------------------------------------
        if ( ! is_array( $url ) && ! $url )
        {
            Core_Redirect( DEVIL_APP_DEFAULT_CONTROLLER );
        }
        # ----------------------------------------------------------------------
        # 這邊將每一個 Params 處理到 Debuger 中
        # ----------------------------------------------------------------------
        foreach( $url as $key => $val )
        {
            if ( $key == 0 )
            {
                self::$_debug->addMessage( 'params' , 'Controller' , $val );
            }
            elseif ( $key == 1 )
            {
                self::$_debug->addMessage( 'params' , 'Method' , $val );
            }
            else
            {
                self::$_debug->addMessage( 'params' , 'param_' . ( $key - 1 ) , $val );
            }
        }
        # ----------------------------------------------------------------------
        # 建立一個 "核心路由" 的啟動訊息
        # ----------------------------------------------------------------------
        self::$_debug->addMessage( 'log' , 'Bootstart-Core-Router-Start' , array() );
        # ----------------------------------------------------------------------
        # 預設專案的 Controller
        # ----------------------------------------------------------------------
        $defineIndex = DEVIL_APP_DEFAULT_CONTROLLER;
        # ----------------------------------------------------------------------
        # 如果沒有任何 Controller 就使用預設的
        # ----------------------------------------------------------------------
        $class = ( isset( $url[0] ) ) ? $url[0] : $defineIndex;
        # ----------------------------------------------------------------------
        # 設置預設的 Controller 路徑
        # ----------------------------------------------------------------------
        $file = DEVIL_APP_APPLOCATION . 'controllers' . DIRECTORY_SEPARATOR . $class . '.php';
        # ----------------------------------------------------------------------
        # 如果沒有呼叫任何 Controller 就執行預設 Controller
        # ----------------------------------------------------------------------
        if ( file_exists( $file ) )
        {
            # ------------------------------------------------------------------
            # 引入檔案
            # ------------------------------------------------------------------
            require ( $file );
            # ------------------------------------------------------------------
            # 實體化 控制器
            # ------------------------------------------------------------------
            $core = new $class;
            # ------------------------------------------------------------------
            # 實體化 控制器
            # ------------------------------------------------------------------
            self::$_Controller_Object = $core;
            # ------------------------------------------------------------------
            # 這邊判斷 使用者呼叫控制器中的 "Method" 有沒有設定
            # ------------------------------------------------------------------
            $url[1] = ( isset( $url[1] ) ) ? $url[1] : null;
            # ------------------------------------------------------------------
            # 如果只有呼叫 Controller , 而沒有另外呼叫 Method, 就是代表呼叫 index
            # ------------------------------------------------------------------
            if ( $url[1] === null )
            {
                # --------------------------------------------------------------
                # 這邊將當前呼叫的 "控制器" 存放到 Bootstart 的 $_Controller 變數中
                # --------------------------------------------------------------
                self::$_Controller = $class;
                # --------------------------------------------------------------
                # 這邊就是直接塞 index ( 因為 "Method" 沒設置 )
                # --------------------------------------------------------------
                self::$_Method = 'index';
                # --------------------------------------------------------------
                # 這邊就直接執行 當前控制器的 index Method
                # --------------------------------------------------------------
                $core->index();
            }
            # ------------------------------------------------------------------
            # 如果有呼叫 Method，例如  http://localhost/controller/method/
            # ------------------------------------------------------------------
            else
            {
                # --------------------------------------------------------------
                # 禁止直接從網址存取建構子、解構子
                # --------------------------------------------------------------
                $banArr = array( '__construct' , '__destruct' );
                # --------------------------------------------------------------
                # 利用PHP內建的 "method_exists" 來判斷指定的 method 有沒有存在 Class 中
                # --------------------------------------------------------------
                if ( method_exists( $core , $url[1] ) && ! in_array( $url[1] , $banArr ) )
                {
                    # ----------------------------------------------------------
                    # 將 $url[1] 變數另外存放至 $method 變數
                    # ----------------------------------------------------------
                    $method = $url[1];
                    # ----------------------------------------------------------
                    # 判斷 $url ( 從外部帶進來的 )，如果大於 1 就代表有傳參數
                    # $url[0] = Controller ( 控制器 )
                    # $url[1] = Method ( 控制器的功能 )
                    # $url[2~~~??] = Param ( 控制器功能所需要的參數 )
                    # ----------------------------------------------------------
                    if ( count( $url ) > 1 )
                    {
                        # ------------------------------------------------------
                        # 這邊再把已經另外處理後的路由參數 移除
                        # ------------------------------------------------------
                        unset( $url[0] , $url[1] );
                        # ------------------------------------------------------
                        # 所以當前的 $url 僅剩下參數的部分，再放到 $param 中
                        # ------------------------------------------------------
                        $param = $url;
                    }
                    else
                    {
                        # ------------------------------------------------------
                        # 這邊因為沒有大於 1 所以代表沒有傳入任何的參數，所以處理成空陣列
                        # ------------------------------------------------------
                        $param = array();
                    }
                    # ----------------------------------------------------------
                    # 這邊將當前呼叫的 "控制器" 存放到 Bootstart 的 $_Controller 變數中
                    # ----------------------------------------------------------
                    self::$_Controller = $class;
                    # ----------------------------------------------------------
                    # 這邊將當前呼叫的 "控制器功能" 存放到 Bootstart 的 $_Method 變數中
                    # ----------------------------------------------------------
                    self::$_Method = $method;
                    # ----------------------------------------------------------
                    # 這邊將當前呼叫的 "控制器功能需要的參數" 存放到 Bootstart 的 $_Uri 變數中
                    # ----------------------------------------------------------
                    self::$_Uri = $param;
                    # ----------------------------------------------------------
                    # 利用 PHP 內建的 call_user_func_array 來處理，這樣可自動帶入參數呼叫
                    # ----------------------------------------------------------
                    call_user_func_array( array( $core , $method ) , $param );
                }
                else
                {
                    # ----------------------------------------------------------
                    # 如果是正式上線模式，就不顯示錯誤提示，直接導向至預設的 控制器
                    # ----------------------------------------------------------
                    if ( DEVIL_APP_ENVIRONMENT !== 'production' )
                    {
                        # ------------------------------------------------------
                        # 開發中的提示 ( 會中斷 )
                        # ------------------------------------------------------
                        show_error( '您所加載的控制項目函式不存在' );
                    }
                    else
                    {
                        # ------------------------------------------------------
                        # 亂測的就直接導向到預設的 Controllers
                        # ------------------------------------------------------
                        Core_Redirect( DEVIL_APP_DEFAULT_CONTROLLER );
                    }
                }
            }
        }
        else
        {
            # ------------------------------------------------------------------
            # 如果是正式上線模式，就不顯示效能
            # ------------------------------------------------------------------
            if ( DEVIL_APP_ENVIRONMENT !== 'production' )
            {
                show_error( '您所加載的控制項目不存在，請檢查專案或核心下的 Controllers 目錄有無: ' . $class . ' 存在' );
            }
            else
            {
                # --------------------------------------------------------------
                # 亂測的就直接導向到預設的 Controllers
                # --------------------------------------------------------------
                Core_Redirect( DEVIL_APP_DEFAULT_CONTROLLER );
            }
        }
    }
}